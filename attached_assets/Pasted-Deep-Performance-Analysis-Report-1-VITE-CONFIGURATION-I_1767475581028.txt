Deep Performance Analysis Report
1. VITE CONFIGURATION ISSUES
Current vite.config.ts:
export default defineConfig({
plugins: [react(), runtimeErrorOverlay(), themePlugin()],
resolve: { ... },
build: {
outDir: path.resolve(__dirname, "dist/public"),
emptyOutDir: true,
},
});

Problems Identified:
* âŒÂ NoÂ optimizeDepsÂ configurationÂ - Vite isn't explicitly pre-bundling heavy dependencies
* âŒÂ No manual chunks splittingÂ - All code goes into one big bundle
* âŒÂ NoÂ manualChunksÂ configurationÂ for production builds
* âŒÂ Cache busting withÂ nanoid()Â inÂ server/vite.tsÂ (line 62-63) forces the browser to re-downloadÂ main.tsxÂ on EVERY page load

2. HEAVY DEPENDENCIES LOADED EAGERLY
Package	Size	Impact
googleapis	114MB	Backend only but affects server startup
react-icons	83MB	Loaded eagerly (only 2 imports found)
@firebaseÂ +Â firebase	105MB combined	Imported inÂ App.tsxÂ viaÂ @/lib/firebase
date-fns	36MB	Full library loaded
lucide-react	33MB	116+ import statements found
framer-motion	~20MB	Imported in 22+ files including landing page
Critical Issue:Â Firebase is imported synchronously at the top level ofÂ App.tsx:
import "@/lib/firebase"; // Line 20 - blocks initial render


3. LANDING PAGE ANALYSIS (LandingStealth)
The default landing page (/) loads:
* 1,250 linesÂ of code (largest feature file)
* ~10 static image importsÂ (testimonials, mascot, backgrounds)
* Framer MotionÂ animations (22KB+ unminified)
* NOT lazy loadedÂ - imported directly inÂ App.tsx:
import LandingStealth from "@/features/landing-stealth"; // Line 27

Other landing pages also imported eagerly:
import Landing from "@/pages/landing";
import Landing2 from "@/pages/landing2";


4. BARREL FILE EXPORTS (Major Dev-Mode Slowdown)
FoundÂ 20+ barrel index filesÂ that re-export everything:
// client/src/features/guidance-engine/index.ts
export * from "./types";
export * from "./components"; // Loads ALL components
export * from "./hooks/useGuidanceEngine";
export * from "./quests";
export * from "./context";

Problem:Â When you import from a barrel file, Vite must transform ALL exported modules even if you only need one.

5. PROVIDER NESTING (Render Blocking)
App.tsxÂ hasÂ 8 nested providersÂ that must all initialize before any content renders:
<QueryClientProvider>
<ThemeProvider>
<InsufficientCreditsProvider>
<AuthProvider>
<RegistrationModalProvider>
<StrategyOverlayProvider>
<GuidanceProvider>
<Router /> // Content finally renders here

Each provider may trigger API calls or localStorage reads on mount.

6. BLOCKING SCRIPTS INÂ index.html
<!-- Google Analytics - render blocking -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4K01JPM2D8"></script>

<!-- Theme bootstrap - synchronous -->
<script>
(function() {
const stored = localStorage.getItem('theme');
...
})();
</script>

<!-- Google Fonts - render blocking -->
<link href="https://fonts.googleapis.com/css2?family=..." rel="stylesheet">


7. VITE DEV-MODE SPECIFIC ISSUES
InÂ server/vite.ts:
template = template.replace(
`src="/src/main.tsx"`,
`src="/src/main.tsx?v=${nanoid()}"`, // Line 62-63
);

This defeats Vite's cachingÂ by adding a unique query string on every page load, forcing the browser to re-fetch and re-parse the entire module graph.

8. PRE-BUNDLED DEPENDENCIES
CheckedÂ node_modules/.vite/deps/Â - found pre-bundled chunks but:
* Some chunks areÂ 180KB+Â (chunk-6PJ6ZD5Z.js)
* React Query, React DOM, and core libraries are bundled together
* No evidence of strategic chunk splitting

SUMMARY OF ROOT CAUSES
			
			
			
			
			
			
			
Priority	Issue	Impact	Category
ğŸ”´ HIGH	Firebase imported synchronously	Blocks initial render	Bundle
RECOMMENDED OPTIMIZATIONS (for when you're ready)
1. Lazy load the landing pageÂ like other routes
2. Add manual chunksÂ for heavy deps (Firebase, Framer Motion, Recharts)
3. ConfigureÂ optimizeDeps.includeÂ for known heavy dependencies
4. Remove theÂ nanoid()Â cache busterÂ in development
5. Split barrel exportsÂ into direct imports
6. Defer Firebase initializationÂ until after initial render
7. Preload critical fontsÂ withÂ font-display: swap
8. Move heavy providersÂ outside the critical render path
Would you like me to proceed with implementing any of these optimizations?


